#kernel Seed
#kernel Automaton
#kernel Blit

#extension GL_ARB_gpu_shader_int64 : require


layout(rgba8, set = 0, binding = 0) uniform image2D _RenderTarget;
layout(r16f, set = 0, binding = 2) uniform image2D _AutomatonFrom;
layout(r16f, set = 0, binding = 3) uniform image2D _AutomatonTo;

struct Neighborhood {
	uint64_t upper_left_mask;
	uint64_t upper_right_mask;
	uint64_t lower_left_mask;
	uint64_t lower_right_mask;
};

layout(binding = 1) uniform UniformBufferObject {
	ivec4 _RuleRanges;
	ivec4 _RuleRanges2;
	ivec4 _RuleRanges3;
	ivec4 _RuleRanges4;
	int _Seed;
	int _Zoom;
	ivec2 _Offset;
};

layout(push_constant, std430) uniform Params {
	Neighborhood _Neighborhood1;
	Neighborhood _Neighborhood2;
	Neighborhood _Neighborhood3;
	Neighborhood _Neighborhood4;
};

float pseudo(vec2 v) {
	v = fract(v/128.)*128. + vec2(-64.340622, -72.465622);
	return fract(dot(v.xyx * v.xyy, vec3(20.390625, 60.703125, 2.4281209)));
}

[numthreads(8, 8, 1)]
void Seed() {
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	ivec2 seeds = uv + ivec2(_Seed, _Seed * 2);

	float seed = pseudo(vec2(seeds.x * 0.1, seeds.y * 0.1));

	if (seed < 0.75) seed = 0.0;
	else seed = 1.0;

	if (_Seed.x == 42069) {
		if (uv.x == 26 && uv.y == 24) seed = 1;
		else seed = 0;
	}

	imageStore(_AutomatonFrom, uv, vec4(seed));
}


uint64_t encode_tile_to_uint(ivec2 uv) {
	uint64_t tile_bits = 0;

	for (int y = 0; y < 8; ++y) {
		for (int x = 0; x < 8; ++x) {
			uint bit_index = x + y * 8; // Convert to 1D index in 64 bit uint

			ivec2 world_coords = uv + ivec2(-x, -y);
			uint64_t cell_value = int(imageLoad(_AutomatonFrom, world_coords % 1024).r);

			tile_bits |= (cell_value << bit_index);
		}
	}
	
	return tile_bits;
}


[numthreads(8, 8, 1)]
void Automaton() {
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	int cell = int(imageLoad(_AutomatonFrom, uv).r);
	
	uint64_t top_row_mask = 18374686479671623680UL;
	uint64_t left_column_mask = 9259542123273814144UL;

	// GAME OF LIFE
	// uint64_t upper_left_mask = 770;
	// uint64_t upper_right_mask = 49216 & ~(left_column_mask);
	// uint64_t lower_left_mask = 144959613005987840UL & ~(top_row_mask);
	// uint64_t lower_right_mask = 4665729213955833856UL & ~(top_row_mask | left_column_mask);

	// BUGS
	// uint64_t upper_left_mask = 69540876599103UL;
	// uint64_t upper_right_mask = 278163506396412UL & ~(left_column_mask);
	// uint64_t lower_left_mask = 4557430888798814208UL & ~(top_row_mask);
	// uint64_t lower_right_mask = 18229723555195256832UL & ~(top_row_mask | left_column_mask);

	uint64_t upper_left_mask = _Neighborhood1.upper_left_mask;
	uint64_t upper_right_mask = _Neighborhood1.upper_right_mask & ~(left_column_mask);
	uint64_t lower_left_mask = _Neighborhood1.lower_left_mask & ~(top_row_mask);
	uint64_t lower_right_mask = _Neighborhood1.lower_right_mask & ~(top_row_mask | left_column_mask);

	uint64_t upper_left_mask2 = _Neighborhood2.upper_left_mask;
	uint64_t upper_right_mask2 = _Neighborhood2.upper_right_mask & ~(left_column_mask);
	uint64_t lower_left_mask2 = _Neighborhood2.lower_left_mask & ~(top_row_mask);
	uint64_t lower_right_mask2 = _Neighborhood2.lower_right_mask & ~(top_row_mask | left_column_mask);

	uint64_t upper_left_mask3 = _Neighborhood3.upper_left_mask;
	uint64_t upper_right_mask3 = _Neighborhood3.upper_right_mask & ~(left_column_mask);
	uint64_t lower_left_mask3 = _Neighborhood3.lower_left_mask & ~(top_row_mask);
	uint64_t lower_right_mask3 = _Neighborhood3.lower_right_mask & ~(top_row_mask | left_column_mask);

	uint64_t upper_left_mask4 = _Neighborhood4.upper_left_mask;
	uint64_t upper_right_mask4 = _Neighborhood4.upper_right_mask & ~(left_column_mask);
	uint64_t lower_left_mask4 = _Neighborhood4.lower_left_mask & ~(top_row_mask);
	uint64_t lower_right_mask4 = _Neighborhood4.lower_right_mask & ~(top_row_mask | left_column_mask);


	uint64_t upper_left_quadrant_bits = encode_tile_to_uint(uv);
	uint64_t upper_right_quadrant_bits = encode_tile_to_uint(uv + ivec2(7, 0));
	uint64_t lower_left_quadrant_bits = encode_tile_to_uint(uv + ivec2(0, 7));
	uint64_t lower_right_quadrant_bits = encode_tile_to_uint(uv + ivec2(7, 7));

	uint64_t neighbor_count1 = 0;
	neighbor_count1 += bitCount(upper_left_quadrant_bits & upper_left_mask);
	neighbor_count1 += bitCount(upper_right_quadrant_bits & upper_right_mask);
	neighbor_count1 += bitCount(lower_left_quadrant_bits & lower_left_mask);
	neighbor_count1 += bitCount(lower_right_quadrant_bits & lower_right_mask);
	
	uint64_t neighbor_count2 = 0;
	neighbor_count2 += bitCount(upper_left_quadrant_bits & upper_left_mask2);
	neighbor_count2 += bitCount(upper_right_quadrant_bits & upper_right_mask2);
	neighbor_count2 += bitCount(lower_left_quadrant_bits & lower_left_mask2);
	neighbor_count2 += bitCount(lower_right_quadrant_bits & lower_right_mask2);
	
	uint64_t neighbor_count3 = 0;
	neighbor_count3 += bitCount(upper_left_quadrant_bits & upper_left_mask3);
	neighbor_count3 += bitCount(upper_right_quadrant_bits & upper_right_mask3);
	neighbor_count3 += bitCount(lower_left_quadrant_bits & lower_left_mask3);
	neighbor_count3 += bitCount(lower_right_quadrant_bits & lower_right_mask3);

	int64_t neighbor_count4 = 0;
	neighbor_count4 += bitCount(upper_left_quadrant_bits & upper_left_mask4);
	neighbor_count4 += bitCount(upper_right_quadrant_bits & upper_right_mask4);
	neighbor_count4 += bitCount(lower_left_quadrant_bits & lower_left_mask4);
	neighbor_count4 += bitCount(lower_right_quadrant_bits & lower_right_mask4);


	// for (int x = -1; x <= 1; ++x) {
	// 	for (int y = -1; y <= 1; ++y) {
	// 		if (x == 0 && y == 0) continue;

	// 		ivec2 texcoords = uv + ivec2(x, y);
	// 		texcoords = texcoords % 512;

	// 		neighbor_count += int(imageLoad(_AutomatonFrom, texcoords).r);
	// 	}
	// }

	// if (neighbor_count <= 1) cell = 0;
	// if (neighbor_count == 3) cell = 1;
	// if (neighbor_count >= 4) cell = 0;


	if (_RuleRanges.x <= neighbor_count1 && neighbor_count1 <= _RuleRanges.y) { // Spawn
		cell = 1;
	} else if (_RuleRanges.z <= neighbor_count1 && neighbor_count1 <= _RuleRanges.w) { // Stable
		cell = cell;
	} else {
		cell = 0; // RIP
	}

	if (_RuleRanges2.x <= neighbor_count2 && neighbor_count2 <= _RuleRanges2.y) { // Spawn
		cell = 1;
	} else if (_RuleRanges2.z <= neighbor_count2 && neighbor_count2 <= _RuleRanges2.w) { // Stable
		cell = cell;
	} else {
		cell = 0; // RIP
	}

	if (_RuleRanges3.x <= neighbor_count3 && neighbor_count3 <= _RuleRanges3.y) { // Spawn
		cell = 1;
	} else if (_RuleRanges3.z <= neighbor_count3 && neighbor_count3 <= _RuleRanges3.w) { // Stable
		cell = cell;
	} else {
		cell = 0; // RIP
	}

	if (_RuleRanges4.x <= neighbor_count4 && neighbor_count4 <= _RuleRanges4.y) { // Spawn
		cell = 1;
	} else if (_RuleRanges4.z <= neighbor_count4 && neighbor_count4 <= _RuleRanges4.w) { // Stable
		cell = cell;
	} else {
		cell = 0; // RIP
	}

	imageStore(_AutomatonTo, uv, vec4(cell));
}

[numthreads(8, 8, 1)]
void Blit() {
	ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	float automata = imageLoad(_AutomatonFrom, ((uv + _Offset * _Zoom) / _Zoom) % 1024).r;
	
	imageStore(_RenderTarget, uv, vec4(automata, automata, automata, 1.0));
}
